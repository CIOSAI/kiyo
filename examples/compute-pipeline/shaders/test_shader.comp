#version 450

#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) * 43758.5453123)
#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)

layout ( binding = 0, rgba8 ) uniform image2D outImage;

mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(1, 0, 0),
    vec3(0, c, -s),
    vec3(0, s, c)
    );
}

mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(c, 0, s),
    vec3(0, 1, 0),
    vec3(-s, 0, c)
    );
}

mat3 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(c, -s, 0),
    vec3(s, c, 0),
    vec3(0, 0, 1)
    );
}

void drawLine( ivec2 start, ivec2 end, vec3 color )
{
    ivec2 delta = end - start;
    ivec2 absDelta = abs( delta );
    ivec2 sign = sign( delta );

    if( absDelta.x > absDelta.y )
    {
        int d = 2 * absDelta.y - absDelta.x;
        int incrE = 2 * absDelta.y;
        int incrNE = 2 * ( absDelta.y - absDelta.x );

        ivec2 p = start;
        imageStore( outImage, p, vec4( color, 1 ) );

        while( p.x != end.x )
        {
            if( d <= 0 )
            {
                d += incrE;
                p.x += sign.x;
            }
            else
            {
                d += incrNE;
                p.x += sign.x;
                p.y += sign.y;
            }

            imageStore( outImage, p, vec4( color, 1 ) );
        }
    }
    else
    {
        int d = 2 * absDelta.x - absDelta.y;
        int incrE = 2 * absDelta.x;
        int incrNE = 2 * ( absDelta.x - absDelta.y );

        ivec2 p = start;
        imageStore( outImage, p, vec4( color, 1 ) );

        while( p.y != end.y )
        {
            if( d <= 0 )
            {
                d += incrE;
                p.y += sign.y;
            }
            else
            {
                d += incrNE;
                p.x += sign.x;
                p.y += sign.y;
            }

            imageStore( outImage, p, vec4( color, 1 ) );
        }
    }
}

void main()
{
    ivec2 screenSize = imageSize( outImage );

    vec3 pos = vec3( ivec2(gl_GlobalInvocationID.xy) - ivec2( 10 ), 0 );

    // Rotate
    vec3 p1 = rotateX( .4f ) * pos;
    p1 = rotateY( 1.2f ) * p1;

    float len = 2.0f;
    vec3 p2 = rotateX( .4f ) * ( pos + vec3( 0, 0, len ) );
    p2 = rotateY( 1.2f ) * p2;

    // Scale
    float scale = 30.0f;
    p1 *= scale;
    p2 *= scale;

    // Map position to screen space
    ivec2 ip1 = ivec2( p1.xy );
    ivec2 ip2 = ivec2( p2.xy );

    // Center the compute data
    ivec2 offset = screenSize / 2;
    ip1 += offset;
    ip2 += offset;

    vec3 color = hash3( gl_GlobalInvocationID.xyz + ivec3(1) );
    drawLine( ip1, ip2, color );

}