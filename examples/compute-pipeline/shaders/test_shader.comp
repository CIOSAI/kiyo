#version 450

#define WORKGROUP_SIZE 12
layout ( local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) * 43758.5453123)
#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)

layout( binding = 0, rgba8 ) uniform image2D outImage;

layout( push_constant ) uniform PushConstants
{
    float time;
} constants;

mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(1, 0, 0),
    vec3(0, c, -s),
    vec3(0, s, c)
    );
}

mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(c, 0, s),
    vec3(0, 1, 0),
    vec3(-s, 0, c)
    );
}

mat3 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(c, -s, 0),
    vec3(s, c, 0),
    vec3(0, 0, 1)
    );
}

void drawLine( ivec2 start, ivec2 end, vec3 c1, vec3 c2 )
{
    ivec2 delta = end - start;
    ivec2 absDelta = abs( delta );
    ivec2 sign = sign( delta );

    if( absDelta.x > absDelta.y )
    {
        int d = 2 * absDelta.y - absDelta.x;
        int incrE = 2 * absDelta.y;
        int incrNE = 2 * ( absDelta.y - absDelta.x );

        ivec2 p = start;
        imageStore( outImage, p, vec4( c1, 1 ) );

        while( p.x != end.x )
        {
            if( d <= 0 )
            {
                d += incrE;
                p.x += sign.x;
            }
            else
            {
                d += incrNE;
                p.x += sign.x;
                p.y += sign.y;
            }

            float t = float( abs( p.x - start.x ) ) / float( absDelta.x );
            imageStore( outImage, p, vec4( c1 * t + c2 * ( 1.0f - t ), 1 ) );
        }
    }
    else
    {
        int d = 2 * absDelta.x - absDelta.y;
        int incrE = 2 * absDelta.x;
        int incrNE = 2 * ( absDelta.x - absDelta.y );

        ivec2 p = start;
        imageStore( outImage, p, vec4( c1, 1 ) );

        while( p.y != end.y )
        {
            if( d <= 0 )
            {
                d += incrE;
                p.y += sign.y;
            }
            else
            {
                d += incrNE;
                p.x += sign.x;
                p.y += sign.y;
            }

            float t = float( abs( p.x - start.x ) ) / float( absDelta.x );
            imageStore( outImage, p, vec4( c1 * t + c2 * ( 1.0f - t ), 1 ) );
        }
    }
}

mat4 projMatrix()
{
    mat4 m = mat4(1.0);
    float near = 0.1;
    float far = 100.0;
    float angleOfView = 90.0;
    float scale = 1 / tan(angleOfView * 0.5 * 3.1415 / 180);
    m[0][0] = scale;  // scale the x coordinates of the projected point
    m[1][1] = scale;  // scale the y coordinates of the projected point
    m[2][2] = -far / (far - near);  // used to remap z to [0,1]
    m[3][2] = -far * near / (far - near);  // used to remap z [0,1]
    m[2][3] = -1;  // set w = -z
    m[3][3] = 0;
    return m;
}

vec3 transform( vec3 pos )
{
    vec3 p = pos;
    p = rotateY( 1.2f * constants.time * .1f ) * p;
    p = ( projMatrix() * vec4( p, 1 ) ).xyz;

    return p;
}

void draw( vec3 p1, vec3 p2, ivec2 screenSize, vec3 c1, vec3 c2 )
{
    p1 = transform( p1 );
    p2 = transform( p2 );

    // Scale
    p1 *= 300.0f;
    p2 *= 300.0f;

    // Map position to screen space
    ivec2 ip1 = ivec2( p1.xy );
    ivec2 ip2 = ivec2( p2.xy );

    // Center the compute data
    ivec2 offset = screenSize / 2;
    ip1 += offset;
    ip2 += offset;

    drawLine( ip1, ip2, c1, c2 );
}

float sdf( vec3 p )
{
    return length( p ) - 0.8f;
}

void ray_cast(vec3 pos, vec3 dir)
{
    float total_dist = 0.0f;
    for( int i = 0; i < 10; i++ )
    {
        if( length( pos ) > 1.3f )
        {
            break;
        }

        float dist = sdf( pos );
        total_dist += dist;
        if( dist < 0.1f )
        {
            dir = reflect( dir, normalize( pos ) * .8f );
        }
        vec3 p2 = pos + dir * dist;

        // Draw
        vec3 color_a = vec3( 0.2f, 0.3f, 0.8f );
        vec3 color_b = vec3( 0.8f, 0.3f, 0.2f );
        float t1 = min( total_dist / 1.0f, 1.0f );
        vec3 c1 = color_a * t1 + color_b * ( 1.0f - t1 );
        float t2 = min( total_dist / 1.0f, 1.0f );
        vec3 c2 = color_a * t2 + color_b * ( 1.0f - t2 );
        draw( pos, p2, imageSize( outImage ), c1, c2 );

        pos = p2;
    }
}

void main()
{
    ivec2 screenSize = imageSize( outImage );

    vec3 pos = vec3( vec2(gl_GlobalInvocationID.xy) / vec2( gl_NumWorkGroups * WORKGROUP_SIZE ) - .5f, 0 );
    pos -= vec3( 0, 0, 1 );

    // Transform
    vec3 p1 = pos;
    float len = 1.0f;
    float expand = 0.6f;
    vec3 p2 = pos + vec3( pos.x * expand, pos.y * expand, len );

    ray_cast( p1, normalize( p2 - p1 ) );
}