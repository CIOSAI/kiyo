#version 450

#define WORKGROUP_SIZE 16
layout ( local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) * 43758.5453123)
#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)

layout( binding = 0, rgba8 ) uniform image2D outImage;

layout( push_constant ) uniform PushConstants
{
    float time;
} constants;

mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(1, 0, 0),
    vec3(0, c, -s),
    vec3(0, s, c)
    );
}

mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(c, 0, s),
    vec3(0, 1, 0),
    vec3(-s, 0, c)
    );
}

mat3 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
    vec3(c, -s, 0),
    vec3(s, c, 0),
    vec3(0, 0, 1)
    );
}

void drawLine( ivec2 start, ivec2 end, vec3 color )
{
    ivec2 delta = end - start;
    ivec2 absDelta = abs( delta );
    ivec2 sign = sign( delta );

    if( absDelta.x > absDelta.y )
    {
        int d = 2 * absDelta.y - absDelta.x;
        int incrE = 2 * absDelta.y;
        int incrNE = 2 * ( absDelta.y - absDelta.x );

        ivec2 p = start;
        imageStore( outImage, p, vec4( color, 1 ) );

        while( p.x != end.x )
        {
            if( d <= 0 )
            {
                d += incrE;
                p.x += sign.x;
            }
            else
            {
                d += incrNE;
                p.x += sign.x;
                p.y += sign.y;
            }

            imageStore( outImage, p, vec4( color, 1 ) );
        }
    }
    else
    {
        int d = 2 * absDelta.x - absDelta.y;
        int incrE = 2 * absDelta.x;
        int incrNE = 2 * ( absDelta.x - absDelta.y );

        ivec2 p = start;
        imageStore( outImage, p, vec4( color, 1 ) );

        while( p.y != end.y )
        {
            if( d <= 0 )
            {
                d += incrE;
                p.y += sign.y;
            }
            else
            {
                d += incrNE;
                p.x += sign.x;
                p.y += sign.y;
            }

            imageStore( outImage, p, vec4( color, 1 ) );
        }
    }
}

mat4 projMatrix()
{
    mat4 m = mat4(1.0);
    float near = 0.1;
    float far = 100.0;
    float angleOfView = 90.0;
    float scale = 1 / tan(angleOfView * 0.5 * 3.1415 / 180);
    m[0][0] = scale;  // scale the x coordinates of the projected point
    m[1][1] = scale;  // scale the y coordinates of the projected point
    m[2][2] = -far / (far - near);  // used to remap z to [0,1]
    m[3][2] = -far * near / (far - near);  // used to remap z [0,1]
    m[2][3] = -1;  // set w = -z
    m[3][3] = 0;
    return m;
}

vec3 transform( vec3 pos )
{
    vec3 p = rotateX( .4f ) * pos;
    p = rotateY( 1.2f * constants.time * .1f ) * p;
    p = ( projMatrix() * vec4( p, 1 ) ).xyz;

    return p;
}

void main()
{
    ivec2 screenSize = imageSize( outImage );

    vec3 pos = vec3( vec2(gl_GlobalInvocationID.xy) / vec2( gl_NumWorkGroups * WORKGROUP_SIZE ) - .5f, 0 );

    // Transform
    vec3 p1 = transform( pos );
    float len = 0.1f;
    vec3 p2 = transform( pos + vec3( 0, 0, len ) );

    // Scale
    p1 *= 600.0f;
    p2 *= 600.0f;

    // Map position to screen space
    ivec2 ip1 = ivec2( p1.xy );
    ivec2 ip2 = ivec2( p2.xy );

    // Center the compute data
    ivec2 offset = screenSize / 2;
    ip1 += offset;
    ip2 += offset;

    vec3 color = hash3( gl_GlobalInvocationID.xyz + ivec3(1) );
    drawLine( ip1, ip2, color );

}